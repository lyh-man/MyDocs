# 设计模式（23 种 Design Pattern）

## 一、设计模式
### 1、是什么？
+ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、代码设计经验的总结。

### 2、有啥用？
```text
提高代码可读性、可拓展性
    设计模式为解决特定问题 提供 统一的解决方案，提高代码可读性，便于团队协作、代码维护。

提高代码复用性
    设计模式通常遵循 "高内聚、低耦合" 的原则，有助于降低代码之间的依赖，从而提高代码的复用性。

减少代码错误和 Bug
    设计模式采用经过验证的解决方案，这有助于降低错误和 Bug 的出现。
```

### 3、分类
```text
创建型 Creational
    关注对象的创建过程，将 对象创建 与 使用 分离，可以更灵活的 创建、使用 对象。

结构型 Structural
    关注对象之间的组织和关系，解决对象结构的复杂性和可扩展性问题。
 
行为型 Behavioral
    关注对象之间的通信和协作，解决对象之间的 职责分配 和 交互问题。
```

## 二、核心思想
### 1、创建型(5 种)
```text
单例 Singleton
    核心思想
        某个类仅能生成一个实例对象，且提供一个 全局访问点。外部通过 全局访问点 获取该实例对象。
    使用场景
        需要 全局共享资源 或者 确定某个类只能有一个实例 或者 频繁创建、销毁某个对象时
    场景举例
        日志管理器、配置文件读取器等。
    关键逻辑
        将类的构造函数设置为私有，仅能在类的内部构建实例对象，防止在类的外部创建实例对象。
        类中提供一个静态方法（比如： public static XX getInstance）作为全局访问点，返回唯一的实例对象。

原型 Prototype
    核心思想
        将一个实例对象视为模板，通过 克隆 现有的实例对象 来创建多个 新的实例对象。不是通过 构造函数 来创建。
    使用场景
        需要创建大量相似的对象，且对象创建过程消耗资源较多时。
    场景举例
        在游戏中创建具有大量相似状态的 角色对象。
    关键逻辑
        定义一个 原型接口，其中包含一个 用于克隆对象 的 clone 方法。
        实现一个 原型类，并重写 clone 方法，调用 clone 可以实现 对象的复制。 

建造者 Builder
    核心思想
        将一个复杂的实例对象 的 构建 与 表现 分离，使得同样的构建过程可以创建不同的表现。不是通过重载多个 构造函数 来创建。
    使用场景
        创建 复杂构建过程 的对象
    场景举例
        具有多个 可选配置 的对象  或者  构建类似流程的 不同对象时
    关键逻辑（构建类似流程的 多个对象时）
        定义一个 建造者抽象类，其中包含一组 用于构建对象 的方法。
        实现多个 建造者类，并重写 构建对象 的方法。
        实现一个 指挥者类，用于控制 建造的过程。
    关键逻辑变种（具有多个 可选配置 的对象）
        在 类 的内部 构建一个 静态内部类 Builder
        Builder 内部采用链式调用 构建对象，并通过 build 方法返回 类的实例对象。
        即 new xx.Builder().setxx().setyy().build() 的形式 构建 实例对象。

工厂方法 Factory Method
    核心思想
        定义了一个创建对象的接口，将 对象的 创建过程 推迟到 子类中进行。
    使用场景
        根据输入参数动态创建 不同类型的对象时。
    场景举例
        支付系统中 根据 不同的支付方式 创建不同的 支付对象。
    关键逻辑
        定义一个 工厂接口，其中包含一个 创建对象 的抽象方法。
        实现多个 工厂类，并重写方法，创建对象。

抽象工厂 Abstract Factory
    核心思想
        提供一个接口，用于创建 一系列 对象，对象的 创建过程 推迟到 子类中进行。
    使用场景
        创建一组具有相同主题的对象时。
    场景举例
        跨平台的 UT 组件库，根据不同的平台提供不同的 UI 组件。
    关键逻辑
        定义一个 工厂接口，其中包含一组 创建对象 的抽象方法。
        实现多个 工厂类，并重写方法，创建对象。
```

### 2、结构型（7 种）
```text
装饰 Decorator
    核心思想
        向一个 现有对象 添加新功能，但不改变其 现有结构。
    使用场景
        需要动态扩展 某个对象 的功能时。
    场景举例
        给 不同种类 的饮料 添加不同的 添加剂。
    关键逻辑
        定义一个 抽象组件类，表示 需要装饰的对象。
        定义一个 抽象装饰类，继承 抽象组件类，内部 关联一个 抽象组件实例。
        实现 具体的 装饰类，可添加新的方法（实现新功能）。

桥接 Bridge
    核心思想
        将 抽象部分 与 实现部分 分离，使得它们 可以 独立的变化。
    使用场景
        在 多个维度 对 某个类 进行拓展时
    场景举例
        买奶茶，划分 容量（中杯、大杯、超大杯）、添加物（加奶、加糖）两个维度。 
    关键逻辑
        定义一个 接口，其中包含 若干个方法。
        实现多个 类，重写 接口方法。
        定义一个 抽象类，其中包含 接口 的引用。
        继承抽象类，重写 抽象方法，内部调用 接口的方法。 

组合 Composite
    核心思想
        将 对象 组合成 树状层次结构。
    使用场景
        需要表示 具有 层次结构 的对象集合时。
    场景举例
        文件系统中的 文件、文件夹
    关键逻辑
        定义一个 抽象组件类，其包含 组合对象 的公共接口。
        实现 具体的 叶子组件类（树形结构 叶子节点） 和 组合类（树形结构 非叶子节点）。

外观 / 门面 Facade
    核心思想
        提供统一的接口，通过该接口 访问 多个子系统。
    使用场景
        简化 子系统 的访问  或者 提供一个 高层次的接口 
    场景举例
        提供简单的 API 来 简化 底层数据库的访问。
    关键逻辑
        定义一个 外观类，其中包含 一系列 子系统实例对象。
        在外观类中，提供简单的方法来调用 子系统实例对象 的方法。

代理 Proxy
    核心思想
        为 某个对象 提供 一种代理，用来控制 对该对象的 访问。
    使用场景
        需要在 访问某个对象时 添加额外的控制， 或者 需要远程访问对象时
    场景举例
        远程代理，虚拟代理
    关键逻辑
        定义一个 抽象类，表示 待代理的对象。
        继承抽象类，实现具体类，重写 抽象类 的方法。
        定义一个 代理类，继承 抽象类，内部关联 一个 抽象类实例。
        在 代理类 中，实现控制逻辑，并调用 抽象类实例 的方法。

适配器 Adapter
    核心思想
        将一个 接口 转换成 另一个 接口，使得原本 不兼容 的类 可以一起工作。
    使用场景
        不修改现有类的情况下且需要兼容其他类时。
    场景举例
        接入第三方库
    关键逻辑
        定义一个 待适配 的实例类。
        定义一个 目标接口。
        实现 目标类，内部关联 待适配的实例类，重写 目标接口方法，并调用 待适配实例类。

享元 Flyweight
    核心思想
        将 常用对象 封装成 共用对象，减少重复对象的创建。
    使用场景
        需要 频繁创建 多个对象时
    场景举例
        线程池、数据库连接池
    关键逻辑
        定义一个 抽象享元类，包含 共享对象 的公共接口。
        实现具体享元类，重写 方法。
        定义一个 工厂类，用于 创建、管理 具体享元类。
```

### 3、行为型（11 种）
```text
观察者 Observer
    核心思想
        对象之间存在 一对多 依赖关系时，当一个 对象状态 发生改变时，会将 改变通知给 依赖于它 的多个对象，从而影响其他对象的行为。
    使用场景
        需要实现 事件驱动的系统 或者 需要实时通知对象状态变化时
    场景举例
        实时天气预报系统
    关键逻辑
        定义一个 观察者接口，包含一个 更新方法
        实现一个 观察者类，重写方法
        定义一个 被观察者接口，包含 添加、通知、删除 观察者 的方法。
        实现一个 被观察者类，重写方法。

中介者 Mediator
    核心思想
        定义一个 对象，内部封装了 一组对象 的交互行为，降低 对象间的 耦合度。
    使用场景
        减少 多个对象 之间直接交互
    场景举例
        MVC 模式中，controller 作为 view 与 Model 的中介者
    关键逻辑
        定义一个 中介者接口，其中包含 各对象交互 的方法。
        实现一个 具体的中介类，重写方法。
        在 各对象 中，使用 中介者对象 来实现交互。

访问者 Visitor
    核心思想
        在不改变 对象结构 的情况下，为对象添加新的操作。
    使用场景
        当一个对象结构包含很多种类的对象，并且这些对象经常发生改变时
    场景举例
        在超市收银系统中，不同的商品可能需要不同的计价方式
    关键逻辑
        定义一个 访问者 接口，其中包含 各种 被访问的元素的 访问操作方法。
        实现一个 访问者类，重写方法。
        在 被访问的 元素中，添加一个接收 访问者 的方法。

备忘录 Memento
    核心思想
        在不破坏封装的前提下，获取并在对象外部保存一个对象的内存状态。
    使用场景
        当需要保存 对象状态，且后续可以恢复时
    场景举例
        文本编辑器 撤销 功能
    关键逻辑
        定义一个 备忘录类，其中包含 用于保存 对象的状态 的方法。
        在需要保存的 对象中，添加创建 和 恢复 备忘录的方法（调用 备忘录实例 方法）。

解释器 Interpreter
    核心思想
        提供 语言的定义 以及 语言定义的解释。
    使用场景
        定义密文格式，并提供 密文解析器（转换为 明文）
    场景举例
        数学表达式求值、SQL 语句解析
    关键逻辑
        定义一个 抽象表达式类，其中包含一个 解释方法。
        实现一个 具体类，重写解释方法。

迭代器 Iterator
    核心思想
        提供一种方法 顺序访问 聚合对象 中的一系列数据，却不暴露 聚合对象 内部表示。
    使用场景
        需要访问 一个聚合对象，且不关心其 内部实现时。
    场景举例
        遍历集合对象
    关键逻辑
        定义一个 迭代器接口，其中包含 遍历 聚合对象 的方法。
        实现一个 具体迭代器类，重写方法。
        定义一个 聚合对象 接口，其中包含一个 创建 迭代器 的方法。
        实现一个 聚合对象类，重写方法，调用 迭代器 的遍历方法。

责任链 Chain of Responsibility
    核心思想
        采用 链式调用，将 一个对象 传递给 下一个对象。
    使用场景
        需要将 请求处理过程 分解成多个步骤，且多个步骤可选时。
    场景举例
        OA 系统中的 审批流程。
    关键逻辑
        定义一个 抽象处理者类， 包含一个 后继处理者 的引用。
        实现一个 处理者类，重写方法，调用 后继处理者。

状态 State
    核心思想
        允许对象在 其内部状态改变时 改变其行为。  被动改变
    使用场景
        当一个行为依赖于状态，且状态需要动态改变时
    场景举例
        播放器的 播放、停止、暂停 状态
    关键逻辑
        定义一个 状态接口，其中包含 对象不同状态下的 行为方法。
        实现一个 状态类，重写方法。
        实现一个 待改变行为的对象，内部包含一个 状态类 的引用，通过状态类对象 实现行为的变化。

策略 Strategy
    核心思想
        定义一系列 算法，将 每个算法 封装起来，使其可以相互替换。 主动改变
    使用场景
        需要根据不同条件选择不同的算法时。
    场景举例
        排序算法
    关键逻辑
        定义一个 策略接口，其中包含多个执行方法。
        实现一个 策略类，重写方法。
        实现一个 待使用策略的对象，内部包含一个 策略类 的引用，通过策略对象 实现算法的切换。

命令 Command
    核心思想
        将 请求 封装为 对象，并传递给 调用对象。 使得 请求发送者 与 请求接受者 解耦。
    使用场景
        请求发送者 与 请求接收者 解耦，可以提供 撤销、恢复 等功能。
    场景举例
        点外卖时，将 商品订单 封装为对象。可以 撤销 订单。
    关键逻辑
        定义一个 命令接口，其中包含一个 方法。
        实现一个 命令类，重写方法。
        定义一个 请求发送者类，其包含一个 命令接口 的引用，可以调用 命令类的实例对象 的执行方法。

模板方法 Template Method
    核心思想
        定义一个操作中的算法结构，将算法的一些步骤延迟到子类中。使子类 在不改变算法结构的情况下 可以重新定义 算法的某些特定步骤。
    使用场景
        操作流程类似，但最终实现方式不同时。
    场景举例
        word 文档转为不同格式文件时（pdf、xps），步骤基本相同，但最终文件格式以及处理方式不同。
    关键逻辑
        定义一个 抽象类，其中包含 模板的 抽象方法。
        实现多个 子类，重写 抽象方法。
```



